//=========================================================================
// Copyright (C) 2012 The Elastos Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//=========================================================================

module
{
    //======================================================
    // Elastos.Utility
    //======================================================
    merge("utility/Exceptions.car");
    merge("utility/IBitSet.car");
    merge("utility/IDate.car");
    merge("utility/ICalendar.car");
    merge("utility/IIterable.car");
    merge("utility/ICollection.car");
    merge("utility/IList.car");
    merge("utility/ILocale.car");
    merge("utility/IMap.car");
    merge("utility/IHashMap.car");
    merge("utility/IHashSet.car");
    merge("utility/IHashTable.car");
    merge("utility/IIdentityHashMap.car");
    merge("utility/ILinkedHashMap.car");
    merge("utility/ILinkedHashSet.car");
    merge("utility/ILinkedList.car");
    merge("utility/IDictionary.car");
    merge("utility/IProperties.car");
    merge("utility/IEnumeration.car");
    merge("utility/IGregorianCalendar.car");
    merge("utility/IIterator.car");
    merge("utility/IListIterator.car");
    merge("utility/IQueue.car");
    merge("utility/IDeque.car");
    merge("utility/IWeakHashMap.car");
    merge("utility/ITreeMap.car");
    merge("utility/ITreeSet.car");
    merge("utility/IRandomAccess.car");
    merge("utility/ITimeZone.car");
    merge("utility/ISimpleTimeZone.car");
    merge("utility/ITimerTask.car");
    merge("utility/ITimer.car");
    merge("utility/ICurrency.car");
    merge("utility/IUUID.car");
    merge("utility/ITimeZoneGetter.car");
    merge("utility/IArrayList.car");
    merge("utility/IFormattableFlags.car");
    merge("utility/IFormatter.car");
    merge("utility/IFormattable.car");
    merge("utility/IArrayDeque.car");
    merge("utility/IEventListener.car");
    merge("utility/IEventListenerProxy.car");
    merge("utility/IEventObject.car");
    merge("utility/IResourceBundle.car");
    merge("utility/IListResourceBundle.car");
    merge("utility/ISortedMap.car");
    merge("utility/INavigableMap.car");
    merge("utility/ISet.car");
    merge("utility/ISortedSet.car");
    merge("utility/INavigableSet.car");
    merge("utility/IObserver.car");
    merge("utility/IObservable.car");
    merge("utility/IPriorityQueue.car");
    merge("utility/IEnumSet.car");
    merge("utility/IHugeEnumSet.car");
    merge("utility/IMiniEnumSet.car");
    merge("utility/IPropertyResourceBundle.car");
    merge("utility/IScanner.car");
    merge("utility/IServiceLoader.car");
    merge("utility/IVector.car");
    merge("utility/IStack.car");
    merge("utility/IStringTokenizer.car");
    merge("utility/IUnsafeArrayList.car");
    merge("utility/IPropertyPermission.car");
    merge("utility/ICollections.car");
    merge("utility/IEnumMap.car");

    //======================================================
    // Elastos.Utility.Regex
    //======================================================
    merge("utility/regex/IMatchResult.car");
    merge("utility/regex/IMatcher.car");
    merge("utility/regex/ISplitter.car");
    merge("utility/regex/IPattern.car");

    //======================================================
    // Elastos.Utility.Logging
    //======================================================
    merge("utility/logging/ILevel.car");
    merge("utility/logging/IErrorManager.car");
    merge("utility/logging/IFilter.car");
    merge("utility/logging/ILogFormatter.car");
    merge("utility/logging/ILogHandler.car");
    merge("utility/logging/ILogger.car");
    merge("utility/logging/ILoggingMXBean.car");
    merge("utility/logging/ILogManager.car");
    merge("utility/logging/ILogRecord.car");
    merge("utility/logging/IStreamHandler.car");
    merge("utility/logging/IConsoleHandler.car");
    merge("utility/logging/IMemoryHandler.car");
    merge("utility/logging/ISimpleFormatter.car");
    merge("utility/logging/ISocketHandler.car");
    merge("utility/logging/IXMLFormatter.car");

    //======================================================
    // Elastos.Utility.Prefs
    //======================================================
    merge("utility/prefs/INodeChangeEvent.car");
    merge("utility/prefs/INodeChangeListener.car");
    merge("utility/prefs/IPreferenceChangeEvent.car");
    merge("utility/prefs/IPreferenceChangeListener.car");
    merge("utility/prefs/IPreferences.car");
    merge("utility/prefs/IPreferencesFactory.car");
    merge("utility/prefs/IXMLParser.car");
    merge("utility/prefs/IAbstractPreferences.car");
    merge("utility/prefs/IFilePreferencesFactoryImpl.car");
    merge("utility/prefs/IFilePreferencesImpl.car");

    merge("utility/spi/ILocaleServiceProvider.car");
    merge("utility/spi/ICurrencyNameProvider.car");
    merge("utility/spi/ILocaleNameProvider.car");
    merge("utility/spi/ITimeZoneNameProvider.car");

    interface Elastos.Core.IAppendable;
    interface Elastos.Core.IComparable;
    interface Elastos.Core.ICloneable;
    interface Elastos.Core.IComparator;
    interface Elastos.IO.ISerializable;
    interface Elastos.IO.IInputStream;
    interface Elastos.IO.IOutputStream;
    interface Elastos.IO.ICloseable;
    interface Elastos.IO.IReader;
    interface Elastos.IO.IReadable;
    interface Elastos.IO.IPrintStream;
    interface Elastos.IO.IFlushable;
    interface Elastos.IO.IFile;
    interface Elastos.IO.Channels.IReadableByteChannel;

    namespace Elastos {
    namespace Utility {

    class CRandom {
        constructor();

        constructor(
            [in] Int64 seed);

        interface IRandom;
        interface ISerializable;
    }

    class CStringTokenizer {
        /**
         * Constructs a new {@code StringTokenizer} for the parameter string using
         * whitespace as the delimiter. The {@code returnDelimiters} flag is set to
         * {@code false}.
         *
         * @param string
         *            the string to be tokenized.
         */
        constructor(
            [in] String string);

        /**
         * Constructs a new {@code StringTokenizer} for the parameter string using
         * the specified delimiters. The {@code returnDelimiters} flag is set to
         * {@code false}. If {@code delimiters} is {@code null}, this constructor
         * doesn't throw an {@code Exception}, but later calls to some methods might
         * throw a {@code NullPointerException}.
         *
         * @param string
         *            the string to be tokenized.
         * @param delimiters
         *            the delimiters to use.
         */
        constructor(
            [in] String string,
            [in] String delimiters);

        /**
         * Constructs a new {@code StringTokenizer} for the parameter string using
         * the specified delimiters, returning the delimiters as tokens if the
         * parameter {@code returnDelimiters} is {@code true}. If {@code delimiters}
         * is null this constructor doesn't throw an {@code Exception}, but later
         * calls to some methods might throw a {@code NullPointerException}.
         *
         * @param string
         *            the string to be tokenized.
         * @param delimiters
         *            the delimiters to use.
         * @param returnDelimiters
         *            {@code true} to return each delimiter as a token.
         */
        constructor(
            [in] String string,
            [in] String delimiters,
            [in] Boolean returnDelimiters);

        interface IStringTokenizer;
        interface IEnumeration;
    }

    class CArrayDeque {
        constructor();

        constructor(
            [in] Int32 numElements);

        constructor(
            [in] ICollection* c);

        interface IArrayDeque;
        interface ICollection;
        interface IIterable;
        interface IDeque;
        interface ICloneable;
        interface ISerializable;
    }

    class CArrayList {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] ICollection* c);

        interface IArrayList;
        interface IList;
        interface ICollection;
        interface IIterable;
        interface ICloneable;
        interface ISerializable;
        interface IRandomAccess;
    }

    class CArrayListIterator {
        constructor(
            [in] IArrayList* list);

        interface IIterator;
    }

    class CSimpleListIterator {
        constructor(
            [in] IList* list);

        interface IIterator;
    }

    class CFullListIterator {
        constructor(
            [in] IList* list,
            [in] Int32 start);

        interface IIterator;
        interface IListIterator;
    }

    class CSubAbstractListIterator {
        constructor(
            [in] IList* list,
            [in] IListIterator* it,
            [in] Int32 offset,
            [in] Int32 length);

        interface IIterator;
        interface IListIterator;
    }

    class CSubAbstractList {
        constructor(
            [in] IList* list,
            [in] Int32 start,
            [in] Int32 end);

        interface IList;
        interface ICollection;
        interface IIterable;
    }

    class CRandomAccessSubList {
        constructor(
            [in] IList* list,
            [in] Int32 start,
            [in] Int32 end);

        interface IRandomAccess;
        interface IList;
        interface ICollection;
        interface IIterable;
    }

    [deprecated]
    class CBitSet {
        constructor();

        constructor(
            [in] Int32 bitCount);

        constructor(
            [in] ArrayOf<Int64>* array);

        interface IBitSet;
        interface ISerializable;
        interface ICloneable;
    }

    singleton class CBitSetHelper {
        interface IBitSetHelper;
    }

    class CEnumMap {
        constructor();

        constructor(
            [in] InterfaceID keyType);

        constructor(
            [in] IEnumMap* enummap);

        constructor(
            [in] IMap* map);

        interface IEnumMap;
        interface ISerializable;
        interface ICloneable;
        interface IMap;
    }

    class CHashMap {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] Int32 capacity,
            [in] Float loadFactor);

        constructor(
            [in] IMap* map);

        interface IHashMap;
        interface IMap;
        interface ICloneable;
        interface ISerializable;
    }

    class CHashSet {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] Int32 capacity,
            [in] Float loadFactor);

        constructor(
            [in] ICollection* collection);

        constructor(
            [in] IMap* backingMap);

        interface IHashSet;
        interface ISet;
        interface ICollection;
        interface IIterable;
        interface ICloneable;
        interface ISerializable;
    }

    class CHashTable {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] Int32 capacity,
            [in] Float loadFactor);

        constructor(
            [in] IMap* backingMap);

        interface IHashTable;
        interface IDictionary;
        interface IMap;
        interface ICloneable;
        interface ISerializable;
    }

    class CIdentityHashMap {
        constructor();

        constructor(
            [in] Int32 maxSize);

        constructor(
            [in] IMap* Map);

        interface IIdentityHashMap;
        interface IMap;
        interface ISerializable;
        interface ICloneable;
    }

    class CLinkedHashMap {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] Int32 capacity,
            [in] Float loadFactor);

        constructor(
            [in] Int32 capacity,
            [in] Float loadFactor,
            [in] Boolean accessOrder);

        constructor(
            [in] IMap* Map);

        interface ILinkedHashMap;
        interface IHashMap;
        interface IMap;
        interface ISerializable;
        interface ICloneable;
    }

    class CLinkedHashSet {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] Int32 capacity,
            [in] Float loadFactor);

        constructor(
            [in] ICollection* collection);

        interface ILinkedHashSet;
        interface IHashSet;
        interface ISet;
        interface ICollection;
        interface ISerializable;
        interface ICloneable;
    }

    class CLinkedList {
        constructor();

        constructor(
            [in] ICollection* collection);

        interface ILinkedList;
        interface IList;
        interface ICollection;
        interface IIterable;
        interface IDeque;
        interface IQueue;
        interface ICloneable;
        interface ISerializable;
    }

    class CVector {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] Int32 capacity,
            [in] Int32 capacityIncrement);

        constructor(
            [in] ICollection* collection);

        interface IVector;
        interface ICollection;
        interface IIterable;
        interface IList;
        interface IRandomAccess;
        interface ICloneable;
        interface ISerializable;
    }

    class CStack {
        constructor();

        interface IStack;
        interface IVector;
        interface ICollection;
        interface IIterable;
        interface IList;
        interface IRandomAccess;
        interface ICloneable;
        interface ISerializable;
    }

    class CWeakHashMap {
        constructor();

        constructor(
            [in] Int32 capacity);

        constructor(
            [in] Int32 capacity,
            [in] Float loadFactor);

        constructor(
            [in] IMap* map);

        interface IWeakHashMap;
        interface IMap;
    }

    class CTreeMap {
        constructor();

        constructor(
            [in] IMap* copyFrommap);

        constructor(
            [in] IComparator* comparator);

        constructor(
            [in] ISortedMap* copyFrom);

        interface ITreeMap;
        interface IMap;
        interface ISortedMap;
        interface INavigableMap;
        interface ICloneable;
        interface ISerializable;
    }

    class CTreeSet {
        constructor();

        constructor(
            [in] INavigableMap* navmap);

        constructor(
            [in] ICollection* map);

        constructor(
            [in] IComparator* comparator);

        constructor(
            [in] ISortedSet* set);

        interface ITreeSet;
        interface ISet;
        interface ICollection;
        interface IIterable;
        interface INavigableSet;
        interface ISortedSet;
        interface ICloneable;
        interface ISerializable;
    }

    class CPriorityQueue {
        constructor();

        constructor(
            [in] Int32 initialCapacity);

        constructor(
            [in] Int32 initialCapacity,
            [in] IComparator* comparator);

        constructor(
            [in] ICollection* co);

        constructor(
            [in] IPriorityQueue* queue);

        constructor(
            [in] ISortedSet* set);

        interface IPriorityQueue;
        interface ICollection;
        interface IIterable;
        interface IQueue;
        interface ISerializable;
    }

    [deprecated]
    class CHugeEnumSet {
        constructor();

        constructor(
            [in] InterfaceID cls,
            [in] ArrayOf<IInterface *> * enums);

        interface IHugeEnumSet;
        interface ICollection;
        interface IIterable;
        interface ISet;
        interface ICloneable;
        interface ISerializable;
    }

    [deprecated]
    class CMiniEnumSet {
        constructor();

        constructor(
            [in] InterfaceID cls,
            [in] ArrayOf<IInterface *> * enums);

        interface IMiniEnumSet;
        interface ICollection;
        interface IIterable;
        interface ISet;
        interface ICloneable;
        interface ISerializable;
    }

    class CUnsafeArrayList {
        constructor();

        constructor(
            [in] InterfaceID elementType,
            [in] Int32 initialCapacity);

        interface IUnsafeArrayList;
        interface ICollection;
        interface IIterable;
        interface IList;
    }

    singleton class CCollections {
        interface ICollections;
    }

    singleton class CEnumSetHelper {
        interface IEnumSetHelper;
    }

    singleton class CCalendarHelper {
        interface ICalendarHelper;
    }

    singleton class CCurrencyHelper {
        interface ICurrencyHelper;
    }

    singleton class CDateHelper {
        interface IDateHelper;
    }

    class CGregorianCalendar {
        /**
         * Constructs a new {@code GregorianCalendar} initialized to the current date and
         * time with the default {@code Locale} and {@code TimeZone}.
         */
        constructor();

        /**
         * Constructs a new {@code GregorianCalendar} initialized to midnight in the default
         * {@code TimeZone} and {@code Locale} on the specified date.
         *
         * @param year
         *            the year.
         * @param month
         *            the month.
         * @param day
         *            the day of the month.
         */
        constructor(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day);

        /**
         * Constructs a new {@code GregorianCalendar} initialized to the specified date and
         * time in the default {@code TimeZone} and {@code Locale}.
         *
         * @param year
         *            the year.
         * @param month
         *            the month.
         * @param day
         *            the day of the month.
         * @param hour
         *            the hour.
         * @param minute
         *            the minute.
         */
        constructor(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day,
            [in] Int32 hour,
            [in] Int32 minute);

        /**
         * Constructs a new {@code GregorianCalendar} initialized to the specified date and
         * time in the default {@code TimeZone} and {@code Locale}.
         *
         * @param year
         *            the year.
         * @param month
         *            the month.
         * @param day
         *            the day of the month.
         * @param hour
         *            the hour.
         * @param minute
         *            the minute.
         * @param second
         *            the second.
         */
        constructor(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day,
            [in] Int32 hour,
            [in] Int32 minute,
            [in] Int32 second);

        constructor(
            [in] Int64 milliseconds);

        /**
         * Constructs a new {@code GregorianCalendar} initialized to the current date and
         * time and using the specified {@code Locale} and the default {@code TimeZone}.
         *
         * @param locale
         *            the {@code Locale}.
         */
        constructor(
            [in] ILocale* locale);

        /**
         * Constructs a new {@code GregorianCalendar} initialized to the current date and
         * time and using the specified {@code TimeZone} and the default {@code Locale}.
         *
         * @param timezone
         *            the {@code TimeZone}.
         */
        constructor(
            [in] ITimeZone* timeZone);

        /**
         * Constructs a new {@code GregorianCalendar} initialized to the current date and
         * time and using the specified {@code TimeZone} and {@code Locale}.
         *
         * @param timezone
         *            the {@code TimeZone}.
         * @param locale
         *            the {@code Locale}.
         */
        constructor(
            [in] ITimeZone* timeZone,
            [in] ILocale* locale);

        constructor(
            [in] Boolean ignored);

        interface IGregorianCalendar;
        interface ICalendar;
        interface ISerializable;
        interface ICloneable;
        interface IComparable;
    }

    class CTimer {
        constructor(
            [in] String name,
            [in] Boolean isDaemon);

        constructor(
            [in] String name);

        constructor(
            [in] Boolean isDaemon);

        constructor();

        interface ITimer;
    }

    class CUUID {
        /**
         * <p>
         * Constructs an instance with the specified bits.
         *
         * @param mostSigBits
         *            The 64 most significant bits of the UUID.
         * @param leastSigBits
         *            The 64 least significant bits of the UUID.
         */
        constructor(
            [in] Int64 mostSigBits,
            [in] Int64 leastSigBits);

        interface IUUID;
        interface IComparable;
        interface ISerializable;
    }

    singleton class CUUIDHelper {
        interface IUUIDHelper;
    }

    singleton class CTimeZoneHelper {
        interface ITimeZoneHelper;
    }

    class CLocale {
        /**
         * There's a circular dependency between toLowerCase/toUpperCase and
         * Locale.US. Work around this by avoiding these methods when constructing
         * the built-in locales.
         *
         * @param unused required for this constructor to have a unique signature
         */
        constructor(
            [in] Boolean unused,
            [in] String lowerCaseLanguageCode,
            [in] String upperCaseCountryCode);

        /**
         * Constructs a new {@code Locale} using the specified language.
         */
        constructor(
            [in] String language);

        /**
         * Constructs a new {@code Locale} using the specified language and country codes.
         */
        constructor(
           [in] String language,
           [in] String country);

        /**
         * Constructs a new {@code Locale} using the specified language, country,
         * and variant codes.
         */
        constructor(
            [in] String language,
            [in] String country,
            [in] String variant);

        constructor(
            [in] String language,
            [in] String country,
            [in] String variant,
            [in] String scriptCode,
            [in] ISet* unicodeAttributes,
            [in] IMap* unicodeKeywords,
            [in] IMap* extensions,
            [in] Boolean hasValidatedFields);

        interface ILocale;
        interface ICloneable;
        interface ISerializable;
    }

    singleton class CLocaleHelper {
        interface ILocaleHelper;
    }

    class CLocaleBuilder {
        constructor();

        interface ILocaleBuilder;
    }

    class CDate {

        constructor();

        //@Deprecated
        constructor(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day);

        //@Deprecated
        constructor(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day,
            [in] Int32 hour,
            [in] Int32 minute);

        //@Deprecated
        constructor(
            [in] Int32 year,
            [in] Int32 month,
            [in] Int32 day,
            [in] Int32 hour,
            [in] Int32 minute,
            [in] Int32 second);

        constructor(
            [in] Int64 milliseconds);

        //@Deprecated
        constructor(
            [in] String string);

        interface IDate;
        interface ISerializable;
        interface ICloneable;
        interface IComparable;
    }

    class CProperties {
        constructor();

        constructor(
            [in] IProperties * properties);

        interface IProperties;
        interface IMap;
        interface ICloneable;
        interface ISerializable;
    }

    class CPropertyResourceBundle {
        constructor();

        /**
         * Constructs a new instance of {@code PropertyResourceBundle} and loads the
         * properties file from the specified {@code InputStream}.
         *
         * @param stream
         *            the {@code InputStream}.
         * @throws IOException
         *             if an error occurs during a read operation on the
         *             {@code InputStream}.
         */
        constructor(
            [in] IInputStream* stream);

        /**
         * Constructs a new resource bundle with properties read from {@code reader}.
         *
         * @param reader the {@code Reader}
         * @throws IOException
         * @since 1.6
         */
        constructor(
            [in] IReader* reader);

        interface IPropertyResourceBundle;
    }

    class CFormatter {
        /**
         * Constructs a {@code Formatter}.
         *
         * <p>The output is written to a {@code StringBuilder} which can be acquired by invoking
         * {@link #out()} and whose content can be obtained by calling {@code toString}.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         */
        constructor();

        /**
         * Constructs a {@code Formatter} whose output will be written to the
         * specified {@code Appendable}.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param a
         *            the output destination of the {@code Formatter}. If {@code a} is {@code null},
         *            then a {@code StringBuilder} will be used.
         */
        constructor(
            [in] IAppendable* a);

        /**
         * Constructs a {@code Formatter} with the specified {@code Locale}.
         *
         * <p>The output is written to a {@code StringBuilder} which can be acquired by invoking
         * {@link #out()} and whose content can be obtained by calling {@code toString}.
         *
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         */
        constructor(
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} with the specified {@code Locale}
         * and whose output will be written to the
         * specified {@code Appendable}.
         *
         * @param a
         *            the output destination of the {@code Formatter}. If {@code a} is {@code null},
         *            then a {@code StringBuilder} will be used.
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         */
        constructor(
            [in] IAppendable* a,
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified file.
         *
         * <p>The charset of the {@code Formatter} is the default charset.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param fileName
         *            the filename of the file that is used as the output
         *            destination for the {@code Formatter}. The file will be truncated to
         *            zero size if the file exists, or else a new file will be
         *            created. The output of the {@code Formatter} is buffered.
         * @throws FileNotFoundException
         *             if the filename does not denote a normal and writable file,
         *             or if a new file cannot be created, or if any error arises when
         *             opening or creating the file.
         */
        constructor(
            [in] String fileName);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified file.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param fileName
         *            the filename of the file that is used as the output
         *            destination for the {@code Formatter}. The file will be truncated to
         *            zero size if the file exists, or else a new file will be
         *            created. The output of the {@code Formatter} is buffered.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @throws FileNotFoundException
         *            if the filename does not denote a normal and writable file,
         *            or if a new file cannot be created, or if any error arises when
         *            opening or creating the file.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] String fileName,
            [in] String csn);

        /**
         * Constructs a {@code Formatter} with the given {@code Locale} and charset,
         * and whose output is written to the specified file.
         *
         * @param fileName
         *            the filename of the file that is used as the output
         *            destination for the {@code Formatter}. The file will be truncated to
         *            zero size if the file exists, or else a new file will be
         *            created. The output of the {@code Formatter} is buffered.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         * @throws FileNotFoundException
         *             if the filename does not denote a normal and writable file,
         *             or if a new file cannot be created, or if any error arises when
         *             opening or creating the file.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] String fileName,
            [in] String csn,
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified {@code File}.
         *
         * The charset of the {@code Formatter} is the default charset.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param file
         *            the {@code File} that is used as the output destination for the
         *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
         *            exists, or else a new {@code File} will be created. The output of the
         *            {@code Formatter} is buffered.
         * @throws FileNotFoundException
         *             if the {@code File} is not a normal and writable {@code File}, or if a
         *             new {@code File} cannot be created, or if any error rises when opening or
         *             creating the {@code File}.
         */
        constructor(
            [in] IFile* file);

        /**
         * Constructs a {@code Formatter} with the given charset,
         * and whose output is written to the specified {@code File}.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param file
         *            the {@code File} that is used as the output destination for the
         *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
         *            exists, or else a new {@code File} will be created. The output of the
         *            {@code Formatter} is buffered.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @throws FileNotFoundException
         *             if the {@code File} is not a normal and writable {@code File}, or if a
         *             new {@code File} cannot be created, or if any error rises when opening or
         *             creating the {@code File}.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] IFile* file,
            [in] String csn);

        /**
         * Constructs a {@code Formatter} with the given {@code Locale} and charset,
         * and whose output is written to the specified {@code File}.
         *
         * @param file
         *            the {@code File} that is used as the output destination for the
         *            {@code Formatter}. The {@code File} will be truncated to zero size if the {@code File}
         *            exists, or else a new {@code File} will be created. The output of the
         *            {@code Formatter} is buffered.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         * @throws FileNotFoundException
         *             if the {@code File} is not a normal and writable {@code File}, or if a
         *             new {@code File} cannot be created, or if any error rises when opening or
         *             creating the {@code File}.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] IFile* file,
            [in] String csn,
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified {@code OutputStream}.
         *
         * <p>The charset of the {@code Formatter} is the default charset.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param os
         *            the stream to be used as the destination of the {@code Formatter}.
         */
        constructor(
            [in] IOutputStream* os);

        /**
         * Constructs a {@code Formatter} with the given charset,
         * and whose output is written to the specified {@code OutputStream}.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param os
         *            the stream to be used as the destination of the {@code Formatter}.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] IOutputStream* os,
            [in] String csn);

        /**
         * Constructs a {@code Formatter} with the given {@code Locale} and charset,
         * and whose output is written to the specified {@code OutputStream}.
         *
         * @param os
         *            the stream to be used as the destination of the {@code Formatter}.
         * @param csn
         *            the name of the charset for the {@code Formatter}.
         * @param l
         *            the {@code Locale} of the {@code Formatter}. If {@code l} is {@code null},
         *            then no localization will be used.
         * @throws UnsupportedEncodingException
         *             if the charset with the specified name is not supported.
         */
        constructor(
            [in] IOutputStream* os,
            [in] String csn,
            [in] ILocale* l);

        /**
         * Constructs a {@code Formatter} whose output is written to the specified {@code PrintStream}.
         *
         * <p>The charset of the {@code Formatter} is the default charset.
         *
         * <p>The {@code Locale} used is the user's default locale.
         * See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
         *
         * @param ps
         *            the {@code PrintStream} used as destination of the {@code Formatter}. If
         *            {@code ps} is {@code null}, then a {@code NullPointerException} will
         *            be raised.
         */
        constructor(
            [in] IPrintStream* ps);

        interface IFormatter;
        interface ICloseable;
        interface IFlushable;
    }

    class CScanner {
        /**
         * Creates a {@code Scanner} with the specified {@code File} as input. The default charset
         * is applied when reading the file.
         *
         * @param src
         *            the file to be scanned.
         * @throws FileNotFoundException
         *             if the specified file does not exist.
         */
        constructor(
            [in] IFile* filesrc);

        /**
         * Creates a {@code Scanner} with the specified {@code File} as input. The specified charset
         * is applied when reading the file.
         *
         * @param src
         *            the file to be scanned.
         * @param charsetName
         *            the name of the encoding type of the file.
         * @throws FileNotFoundException
         *             if the specified file does not exist.
         * @throws IllegalArgumentException
         *             if the specified coding does not exist.
         */
        constructor(
            [in] IFile* filesrc,
            [in] String charsetName);

        /**
         * Creates a {@code Scanner} on the specified string.
         *
         * @param src
         *            the string to be scanned.
         */
        constructor(
            [in] String strsrc);

        /**
         * Creates a {@code Scanner} on the specified {@code InputStream}. The default charset is
         * applied when decoding the input.
         *
         * @param src
         *            the {@code InputStream} to be scanned.
         */
        constructor(
            [in] IInputStream* inputsrc);

        /**
         * Creates a {@code Scanner} on the specified {@code InputStream}. The specified charset is
         * applied when decoding the input.
         *
         * @param src
         *            the {@code InputStream} to be scanned.
         * @param charsetName
         *            the encoding type of the {@code InputStream}.
         * @throws IllegalArgumentException
         *             if the specified character set is not found.
         */
        constructor(
            [in] IInputStream* inputsrc,
            [in] String charsetName);

        /**
         * Creates a {@code Scanner} with the specified {@code Readable} as input.
         *
         * @param src
         *            the {@code Readable} to be scanned.
         */
        constructor(
            [in] IReadable* readsrc);

        /**
         * Creates a {@code Scanner} with the specified {@code ReadableByteChannel} as
         * input. The default charset is applied when decoding the input.
         *
         * @param src
         *            the {@code ReadableByteChannel} to be scanned.
         */
        constructor(
            [in] IReadableByteChannel* rbcsrc);

        /**
         * Creates a {@code Scanner} with the specified {@code ReadableByteChannel} as
         * input. The specified charset is applied when decoding the input.
         *
         * @param src
         *            the {@code ReadableByteChannel} to be scanned.
         * @param charsetName
         *            the encoding type of the content.
         * @throws IllegalArgumentException
         *             if the specified character set is not found.
         */
        constructor(
            [in] IReadableByteChannel* rbcsrc,
            [in] String charsetName);

        interface IScanner;
        interface IIterator;
        interface ICloseable;
    }

    class CSimpleTimeZone {
        /**
         * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT
         * and time zone ID. Timezone IDs can be obtained from
         * {@code TimeZone.getAvailableIDs}. Normally you should use {@code TimeZone.getDefault} to
         * construct a {@code TimeZone}.
         *
         * @param offset
         *            the given base time zone offset to GMT.
         * @param name
         *            the time zone ID which is obtained from
         *            {@code TimeZone.getAvailableIDs}.
         */
        constructor(
            [in] Int32 offset,
            [in] String name);

        /**
         * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT,
         * time zone ID, and times to start and end the daylight savings time. Timezone IDs can
         * be obtained from {@code TimeZone.getAvailableIDs}. Normally you should use
         * {@code TimeZone.getDefault} to create a {@code TimeZone}. For a time zone that does not
         * use daylight saving time, do not use this constructor; instead you should
         * use {@code SimpleTimeZone(rawOffset, ID)}.
         * <p>
         * By default, this constructor specifies day-of-week-in-month rules. That
         * is, if the {@code startDay} is 1, and the {@code startDayOfWeek} is {@code SUNDAY}, then this
         * indicates the first Sunday in the {@code startMonth}. A {@code startDay} of -1 likewise
         * indicates the last Sunday. However, by using negative or zero values for
         * certain parameters, other types of rules can be specified.
         * <p>
         * Day of month: To specify an exact day of the month, such as March 1, set
         * {@code startDayOfWeek} to zero.
         * <p>
         * Day of week after day of month: To specify the first day of the week
         * occurring on or after an exact day of the month, make the day of the week
         * negative. For example, if {@code startDay} is 5 and {@code startDayOfWeek} is {@code -MONDAY},
         * this indicates the first Monday on or after the 5th day of the
         * {@code startMonth}.
         * <p>
         * Day of week before day of month: To specify the last day of the week
         * occurring on or before an exact day of the month, make the day of the
         * week and the day of the month negative. For example, if {@code startDay} is {@code -21}
         * and {@code startDayOfWeek} is {@code -WEDNESDAY}, this indicates the last Wednesday on or
         * before the 21st of the {@code startMonth}.
         * <p>
         * The above examples refer to the {@code startMonth}, {@code startDay}, and {@code startDayOfWeek};
         * the same applies for the {@code endMonth}, {@code endDay}, and {@code endDayOfWeek}.
         * <p>
         * The daylight savings time difference is set to the default value: one hour.
         *
         * @param offset
         *            the given base time zone offset to GMT.
         * @param name
         *            the time zone ID which is obtained from
         *            {@code TimeZone.getAvailableIDs}.
         * @param startMonth
         *            the daylight savings starting month. The month indexing is 0-based. eg, 0
         *            for January.
         * @param startDay
         *            the daylight savings starting day-of-week-in-month. Please see
         *            the member description for an example.
         * @param startDayOfWeek
         *            the daylight savings starting day-of-week. Please see the
         *            member description for an example.
         * @param startTime
         *            the daylight savings starting time in local wall time, which
         *            is standard time in this case. Please see the member
         *            description for an example.
         * @param endMonth
         *            the daylight savings ending month. The month indexing is 0-based. eg, 0 for
         *            January.
         * @param endDay
         *            the daylight savings ending day-of-week-in-month. Please see
         *            the member description for an example.
         * @param endDayOfWeek
         *            the daylight savings ending day-of-week. Please see the member
         *            description for an example.
         * @param endTime
         *            the daylight savings ending time in local wall time, which is
         *            daylight time in this case. Please see the member description
         *            for an example.
         * @throws IllegalArgumentException
         *             if the month, day, dayOfWeek, or time parameters are out of
         *             range for the start or end rule.
         */
        constructor(
            [in] Int32 offset,
            [in] String name,
            [in] Int32 startMonth,
            [in] Int32 startDay,
            [in] Int32 startDayOfWeek,
            [in] Int32 startTime,
            [in] Int32 endMonth,
            [in] Int32 endDay,
            [in] Int32 endDayOfWeek,
            [in] Int32 endTime);

        /**
         * Constructs a {@code SimpleTimeZone} with the given base time zone offset from GMT,
         * time zone ID, times to start and end the daylight savings time, and
         * the daylight savings time difference in milliseconds.
         *
         * @param offset
         *            the given base time zone offset to GMT.
         * @param name
         *            the time zone ID which is obtained from
         *            {@code TimeZone.getAvailableIDs}.
         * @param startMonth
         *            the daylight savings starting month. Month is 0-based. eg, 0
         *            for January.
         * @param startDay
         *            the daylight savings starting day-of-week-in-month. Please see
         *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
         * @param startDayOfWeek
         *            the daylight savings starting day-of-week. Please see the
         *            description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
         * @param startTime
         *            The daylight savings starting time in local wall time, which
         *            is standard time in this case. Please see the description of
         *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
         * @param endMonth
         *            the daylight savings ending month. Month is 0-based. eg, 0 for
         *            January.
         * @param endDay
         *            the daylight savings ending day-of-week-in-month. Please see
         *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
         * @param endDayOfWeek
         *            the daylight savings ending day-of-week. Please see the description of
         *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
         * @param endTime
         *            the daylight savings ending time in local wall time, which is
         *            daylight time in this case. Please see the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)}
         *            for an example.
         * @param daylightSavings
         *            the daylight savings time difference in milliseconds.
         * @throws IllegalArgumentException
         *                if the month, day, dayOfWeek, or time parameters are out of
         *                range for the start or end rule.
         */
        constructor(
            [in] Int32 offset,
            [in] String name,
            [in] Int32 startMonth,
            [in] Int32 startDay,
            [in] Int32 startDayOfWeek,
            [in] Int32 startTime,
            [in] Int32 endMonth,
            [in] Int32 endDay,
            [in] Int32 endDayOfWeek,
            [in] Int32 endTime,
            [in] Int32 daylightSavings);

        /**
         * Construct a {@code SimpleTimeZone} with the given base time zone offset from GMT,
         * time zone ID, times to start and end the daylight savings time including a
         * mode specifier, the daylight savings time difference in milliseconds.
         * The mode specifies either {@link #WALL_TIME}, {@link #STANDARD_TIME}, or
         * {@link #UTC_TIME}.
         *
         * @param offset
         *            the given base time zone offset to GMT.
         * @param name
         *            the time zone ID which is obtained from
         *            {@code TimeZone.getAvailableIDs}.
         * @param startMonth
         *            the daylight savings starting month. The month indexing is 0-based. eg, 0
         *            for January.
         * @param startDay
         *            the daylight savings starting day-of-week-in-month. Please see
         *            the description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
         * @param startDayOfWeek
         *            the daylight savings starting day-of-week. Please see the
         *            description of {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
         * @param startTime
         *            the time of day in milliseconds on which daylight savings
         *            time starts, based on the {@code startTimeMode}.
         * @param startTimeMode
         *            the mode (UTC, standard, or wall time) of the start time
         *            value.
         * @param endDay
         *            the day of the week on which daylight savings time ends.
         * @param endMonth
         *            the daylight savings ending month. The month indexing is 0-based. eg, 0 for
         *            January.
         * @param endDayOfWeek
         *            the daylight savings ending day-of-week. Please see the description of
         *            {@link #SimpleTimeZone(int, String, int, int, int, int, int, int, int, int)} for an example.
         * @param endTime
         *            the time of day in milliseconds on which daylight savings
         *            time ends, based on the {@code endTimeMode}.
         * @param endTimeMode
         *            the mode (UTC, standard, or wall time) of the end time value.
         * @param daylightSavings
         *            the daylight savings time difference in milliseconds.
         * @throws IllegalArgumentException
         *             if the month, day, dayOfWeek, or time parameters are out of
         *             range for the start or end rule.
         */
        constructor(
            [in] Int32 offset,
            [in] String name,
            [in] Int32 startMonth,
            [in] Int32 startDay,
            [in] Int32 startDayOfWeek,
            [in] Int32 startTime,
            [in] Int32 startTimeMode,
            [in] Int32 endMonth,
            [in] Int32 endDay,
            [in] Int32 endDayOfWeek,
            [in] Int32 endTime,
            [in] Int32 endTimeMode,
            [in] Int32 daylightSavings);

        interface ISimpleTimeZone;
        interface ITimeZone;
        interface ICloneable;
        interface ISerializable;
    }

    class CObservable {
        /**
         * Constructs a new {@code Observable} object.
         */
        constructor();

        interface IObservable;
    }

    } // namespace Utility
    } // namespace Elastos

    namespace Elastos {
    namespace Utility {
    namespace Regex {

    /**
     * The result of applying a {@code Pattern} to a given input. See {@link Pattern} for
     * example uses.
     */
    class CMatcher {
        /**
         * Creates a matcher for a given combination of pattern and input. Both
         * elements can be changed later on.
         *
         * @param pattern
         *            the pattern to use.
         * @param input
         *            the input to use.
         */
        constructor(
            [in] IPattern* pattern,
            [in] Elastos.Core.ICharSequence* inputSeq);

        interface IMatcher;
        interface IMatchResult;
    }

    singleton class CMatcherHelper {
        interface IMatcherHelper;
    }

    singleton class CSplitter {
        interface ISplitter;
    }

    singleton class CPatternHelper {
        interface IPatternHelper;
    }

    } // namespace Regex
    } // namesapce Utility
    } // namespace Elastos
}
